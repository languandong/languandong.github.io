<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>03 找出数组中重复的数字</title>
    <url>/2021/03/07/03/</url>
    <content><![CDATA[<Boxx/>
## 1. 题目描述

<p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><p>1 、数组不能为空</p>
<p>2、数组中的数范围为0~n-1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums==<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i]&lt;<span class="number">0</span> || nums[i]&gt;nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>暴力循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==nums[j])</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O($n^2$)</p>
<p>空间复杂度O(1)</p>
<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>原地交换。修改了原来的数组</p>
<p>题目说明尚未被充分使用,即在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。 </p>
<p>此说明含义：数组元素的<strong>索引和值是一对多的关系</strong>。 因此，可遍历数组并通过交换操作，使元素的索引与值对应（即 nums[i] = i）。因而，就能通过索引映射对应的值，起到与字典等价的作用  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    <span class="comment">//循环交换，直到使数组各个值对应其索引 即nums[i]=i</span></span><br><span class="line">    <span class="keyword">while</span>(nums[i]!=i)&#123;</span><br><span class="line">		<span class="comment">//找到重复数字</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i]==nums[nums[i]])&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换位置</span></span><br><span class="line">        temp = nums[i];</span><br><span class="line">        nums[i] = nums[nums[i]];</span><br><span class="line">        nums[nums[i]] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)：遍历数组使用O(n),每次遍历的判断和交换使用O(1)</p>
<p>空间复杂度O(1)：在原数组上操作。只在交换时使用一个变量的额外空间</p>
<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>哈希表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">	<span class="comment">//判断表中的键是否重复</span></span><br><span class="line">    <span class="keyword">if</span>(map.has(nums[i]))&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置键值对</span></span><br><span class="line">    map.set(nums[i],<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n) 一个循环</p>
<p>空间复杂度O(n) 一个map</p>
<h2 id="2-题目描述"><a href="#2-题目描述" class="headerlink" title="2. 题目描述"></a>2. 题目描述</h2><p>不修改数组的情况下找出重复的数字。</p>
<p>在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以必有一个数字是重复的，找出数组中任意一个重复的数字。</p>
<h2 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h2><p>创建一个长度为n+1的辅助数组，逐一把原数组的每个数字都复制到辅助数组。数字m复制到辅助数组中下标m位置，这样容易发现哪个数字重复</p>
<h2 id="解法二-1"><a href="#解法二-1" class="headerlink" title="解法二"></a>解法二</h2><p>类似二分查找</p>
<p>把1~n的数字从中间数字分为两部分，前面一半为1 ~m，后面一段为m+1 ~n。如果1 ~m中数字数目超过m，说明这一段中有重复的数字，否则另一段中有重复的数字。可以继续把包含重复数字的区间一分为二，直到找到一个重复的数字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>04 二维数组中的查找</title>
    <url>/2021/03/08/04/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><ul>
<li><p>matrix不为空  </p>
</li>
<li><p>行数、列数不为0</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(matrix==<span class="literal">null</span>||matrix.length==<span class="number">0</span>||martrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="解法一-暴力循环"><a href="#解法一-暴力循环" class="headerlink" title="解法一 暴力循环"></a>解法一 暴力循环</h2><p>两层循环加if判断</p>
<p>时间复杂度O(mn)</p>
<p>空间复杂度O(1)</p>
<h2 id="解法二-线性查找"><a href="#解法二-线性查找" class="headerlink" title="解法二 线性查找"></a>解法二 线性查找</h2><p>利用给定的二维数组具有从左到右从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。</p>
<p>从二维数组的右上角开始查找。当目标值大于当前值时，说明跳转到下一行查找。当目标值小于当前值时，说明要跳转到上一列查找。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = matrix.length;</span><br><span class="line"><span class="keyword">let</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">let</span> row = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> col = n-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(row&lt;m &amp;&amp; col&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; matrix[row][col])&#123;</span><br><span class="line">        col--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[row][col])&#123;</span><br><span class="line">        row++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(m+n)</p>
<p>空间复杂度O(1)</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>05 替换空格</title>
    <url>/2021/03/09/05/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><p>字符串不为空</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s==<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法一-原地修改"><a href="#解法一-原地修改" class="headerlink" title="解法一 原地修改"></a>解法一 原地修改</h2><p>因为javascript中字符串无法被修改，要花费空间去重新新建一个字符串，从而增加了复杂度。</p>
<p>所以我们这里采用数组来进行操作，流程如下：</p>
<p>1、将字符串转换为数组，然后统计其中的空格数量。<br>2、根据空格数量和原有字符串有效字符长度，计算出刚好存放替换后的字符长度。<br>3、创建两个指针，一个指数组末尾，一个指字符串有效位的末尾，实现原地修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 字符串转为数组</span></span><br><span class="line">  s = s.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="comment">// 统计数组中有几个空格</span></span><br><span class="line">  <span class="keyword">let</span> numOfBlank = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">      numOfBlank++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 指定修改后的数组长度</span></span><br><span class="line">  <span class="keyword">let</span> newLength = s.length + <span class="number">2</span> * numOfBlank;</span><br><span class="line">  <span class="comment">// 定义两个指针</span></span><br><span class="line">  <span class="keyword">let</span> indexOfOriginal = s.length;</span><br><span class="line">  <span class="keyword">let</span> indexOfNew = newLength;</span><br><span class="line">  <span class="comment">// 移动字符</span></span><br><span class="line">  <span class="keyword">while</span>(indexOfNew &gt; indexOfOriginal)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[indexOfOriginal]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">      s[indexOfNew--]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      s[indexOfNew--]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">      s[indexOfNew--]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      s[indexOfNew--]=s[indexOfOriginal];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原指针跳到上一个，准备下一次复制</span></span><br><span class="line">    indexOfOriginal--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>想了好久，两指针相等之后剩下的为什么不用复制了。</p>
<p>因为一直在同一个数组操作，直接保留空格前的。处理完空格的标志就是两个指针相等</p>
<p>时间复杂度O(n) 遍历字符串一遍</p>
<p>空间复杂度O(n) 额外创建一个字符数组</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>06 从尾到头打印链表</title>
    <url>/2021/03/15/06/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<h2 id="解法一-用栈实现"><a href="#解法一-用栈实现" class="headerlink" title="解法一 用栈实现"></a>解法一 用栈实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reversePrint = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> node = head;</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        stack.push(node.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.reverse();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(N)</p>
<p>空间复杂度O(N)</p>
<h2 id="解法二-递归"><a href="#解法二-递归" class="headerlink" title="解法二 递归"></a>解法二 递归</h2><p>递归本身于栈后进先出的原理一致，通过递归从最后一个结果开始保存到数组中，实现倒序打印。</p>
<ul>
<li>递归访问节点</li>
<li>直到最后一个节点的node.next=null 时，逐次保存入数组，一层层函数栈弹出</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [];</span><br><span class="line"><span class="keyword">const</span> visitor = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">        visitor(node.next);</span><br><span class="line">        nums.push(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">visitor(head);</span><br><span class="line"><span class="keyword">return</span> nums;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(N)</p>
<p>空间复杂度O(N)</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>07 重建二叉树</title>
    <url>/2021/03/28/07/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>
<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<h2 id="解法-递归"><a href="#解法-递归" class="headerlink" title="解法 递归"></a>解法 递归</h2><ul>
<li>利用前序遍历和中序遍历的特点<ul>
<li>前序遍历的第一个节点是根节点</li>
<li>在中序遍历中获取根节点的索引，前段为左子树的中序遍历，后段为右子树的中序遍历</li>
<li>得到左子树右子树的长度后，在前序遍历中获取左右子树的前序遍历</li>
</ul>
</li>
<li>递归的退出条件<ul>
<li>切割出来的左右子树的长度都为0</li>
<li>递归建树，从叶子节点开始建立</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">preorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">inorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder.length === <span class="number">0</span> &amp;&amp; inorder.length === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取根节点</span></span><br><span class="line">    <span class="keyword">let</span> root = preorder[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//构造根节点</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取中序遍历中根节点索引</span></span><br><span class="line">    <span class="keyword">let</span> index = inorder.indexOf(root);</span><br><span class="line">    <span class="comment">//切片获取左子树的中序遍历</span></span><br><span class="line">    <span class="keyword">let</span> leftInorder = inorder.slice(<span class="number">0</span>,index);</span><br><span class="line">    <span class="comment">//切片获取右子树的中序遍历</span></span><br><span class="line">    <span class="keyword">let</span> rightInorder = inorder.slice(index+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切片获取左子树的前序遍历</span></span><br><span class="line">    <span class="keyword">let</span> leftPreorder = preorder.slice(<span class="number">1</span>,leftInorder.length+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//切片获取右子树的前序遍历</span></span><br><span class="line">    <span class="keyword">let</span> rightPreorder = preorder.slice(leftInorder.length+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归建树</span></span><br><span class="line">    node.left = buildTree(leftPreorder,leftInorder);</span><br><span class="line">    node.right = buildTree(rightPreorder,rightInorder);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>09 用两个栈实现队列</title>
    <url>/2021/04/07/09/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<h2 id="解法一-双栈"><a href="#解法一-双栈" class="headerlink" title="解法一 双栈"></a>解法一 双栈</h2><p>一个栈无法实现队列功能，栈底的元素无法直接删除，需要上方所有元素出栈。</p>
<p>双栈可以实现列表倒序</p>
<p>维护两个栈，利用栈B实现栈A元素倒序。</p>
<p>利用栈B删除队首元素，倒序后B执行出栈相当于删除了A的栈底元素，即删除队首元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CQueue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stack1 = [];</span><br><span class="line">    <span class="built_in">this</span>.stack2 = [];</span><br><span class="line">&#125;</span><br><span class="line">CQueue.prototype.appendTail = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 栈1保存添加的</span></span><br><span class="line">    <span class="built_in">this</span>.stack1.push(value);</span><br><span class="line">&#125;</span><br><span class="line">CQueue.prototype.deleteHead = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 栈2保存删除的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 栈2不为空则直接弹出</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.stack2.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 栈2空则把1所有值弹入栈2</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">this</span>.stack1.length)&#123;</span><br><span class="line">        	<span class="built_in">this</span>.stack2.push(<span class="built_in">this</span>.stack1.pop());</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 弹出栈2的元素。空了之后返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stack2.pop()||-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：</p>
<p>append为O(1)</p>
<p>Delete为O(n) 需要在n次队首元素删除</p>
<p>空间复杂度O(n)</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>10 斐波那契</title>
    <url>/2021/05/12/10/</url>
    <content><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>

<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h2 id="解法一超时-简单递归"><a href="#解法一超时-简单递归" class="headerlink" title="解法一超时 简单递归"></a>解法一超时 简单递归</h2><p>把f(n)的问题拆分成f(n-1)和f(n-2)两个子问题的计算，并递归，以f(0)和f(1)为终止条件</p>
<p>若递归深度过大，就会导致栈溢出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> n;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ( fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>) ) % <span class="number">1000000007</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>fib函数会重复计算之前的项，计算结果是一次性的，及其浪费时间和空间，无法通过</p>
<h2 id="解法二-循环计算-动态规划（最优）"><a href="#解法二-循环计算-动态规划（最优）" class="headerlink" title="解法二 循环计算+动态规划（最优）"></a>解法二 循环计算+动态规划（最优）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> res2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> t;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            t = res1;</span><br><span class="line">            res1 = res2;</span><br><span class="line">            <span class="comment">// 计算</span></span><br><span class="line">            res2 = (t+res1)%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每次计算的结果都能得到利用，只保存前两个计算记过，性能最优</p>
<p>也可以看作一种动态规划</p>
<p>时间复杂度O(n)</p>
<p>空间复杂度O(1)</p>
<h2 id="解法三-动态规划"><a href="#解法三-动态规划" class="headerlink" title="解法三 动态规划"></a>解法三 动态规划</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">      dp[i+<span class="number">1</span>] = (dp[i]+dp[i-<span class="number">1</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>空间换时间，所有计算结果都被缓存，下一次计算直接读取缓存结果，性能比较好</p>
<p>但需要额外的存储空间，空间复杂度高</p>
<p>动态规划的思想是保存中间计算结果，减少结果计算时间</p>
<p>时间复杂度O(n)</p>
<p>空间复杂度O(n)</p>
<h2 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>此类求多少中可能性的题目一般都有递推性质，即f(n)和f(n-1)…f(1)之间有联系</p>
<p>设跳上n级台阶有f(n)中跳法。在所有跳法中，青蛙的最后一步只有两种情况：跳1级或跳2级</p>
<ul>
<li>当为 1 级台阶： 剩 n−1 个台阶，又有 f(n-1)种跳法；</li>
<li>当为 2 级台阶： 剩 n−2 个台阶，又有 f(n-2) 种跳法。</li>
</ul>
<p>f(n) 为以上两种情况之和，即 f(n)=f(n-1)+f(n-2) ，以上递推性质为斐波那契数列。</p>
<p>本题可转化为求斐波那契数列第n项的值 ，与 上一题斐波那契数列等价，唯一的不同在于起始数字不同。</p>
<ul>
<li>青蛙跳台阶问题： f(0)=1，f(1)=1，f(2)=2；</li>
<li>斐波那契数列问题 f(0)=0，f(1)=1，f(2)=1 。    </li>
</ul>
<p><img src="https://pic.leetcode-cn.com/108249e4d62d429f9cd6cab5bbd6afca581ee61c7d762a4c8ea0c62e08e10762-Picture13.png" alt="Picture13.png"></p>
<h2 id="解法1-循环计算-动态规划（与上题解法只在初始值不同）"><a href="#解法1-循环计算-动态规划（与上题解法只在初始值不同）" class="headerlink" title="解法1 循环计算+动态规划（与上题解法只在初始值不同）"></a>解法1 循环计算+动态规划（与上题解法只在初始值不同）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numWays = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> res2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> t;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            t = res1;</span><br><span class="line">            res1 = res2;</span><br><span class="line">            res2 = (t+res2)%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)</p>
<p>空间复杂度O(1)</p>
<h2 id="解法2-动态规划"><a href="#解法2-动态规划" class="headerlink" title="解法2 动态规划"></a>解法2 动态规划</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numWays = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dp=[<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">      dp[i+<span class="number">1</span>] = (dp[i]+dp[i-<span class="number">1</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)</p>
<p>空间复杂度O(n)</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>11 旋转数组的最小数组</title>
    <url>/2021/05/16/11/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<h2 id="解法一-二分查找"><a href="#解法一-二分查找" class="headerlink" title="解法一 二分查找"></a>解法一 二分查找</h2><p>有序数组的查找问题首先考虑使用二分法解决，其可将遍历法的时间复杂度降到对数级别</p>
<p>这个问题还并不是完全的有序，存在一定的规律即旋转点<strong>左侧数组一定大于等于右侧数组</strong>，通过这样二分法安全缩小范围</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minArray = <span class="function"><span class="keyword">function</span>(<span class="params">numbers</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//二分查找的左右点</span></span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> right = numbers.length;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;right)&#123;</span><br><span class="line">        <span class="comment">//通过差而不是和来算中点，防止溢出</span></span><br><span class="line">        <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor(left+(right-left)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(numbers[mid]&lt;numbers[right])&#123;</span><br><span class="line">            <span class="comment">//中点的值小于右点 中点在右排序数组中 说明旋转点(最小值)一定在[left,mid]</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid]&gt;numbers[right])&#123;</span><br><span class="line">        	<span class="comment">//中点的值大于右点 中点在左排序数组 说明旋转点一定在[mid+1,right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid]==numbers[right])&#123;</span><br><span class="line">            <span class="comment">//相等时无法判定中点在左侧数组还是右侧数组，自然也无法通过二分法安全缩小区间</span></span><br><span class="line">            right--;</span><br><span class="line">            <span class="comment">//即使旋转点是最后一个，前面的区间也有与它相等的值，还是能找出来这个最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(Log n)  二分查找</p>
<p>空间复杂度O(1)</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>12 矩阵中的路径</title>
    <url>/2021/08/04/12/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<h2 id="解法一-DFS-回溯"><a href="#解法一-DFS-回溯" class="headerlink" title="解法一 DFS + 回溯"></a>解法一 DFS + 回溯</h2><ul>
<li>DFS通过递归先朝一个方向搜索到底，再回溯到上一个节点沿另一个方向搜索</li>
<li>剪枝，将访问过的元素</li>
<li>边界条件<ul>
<li>不能越界</li>
<li>判断当前值与搜索值是否相等</li>
<li>判断字符串搜索是否完成</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exist = <span class="function"><span class="keyword">function</span>(<span class="params">board,word</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//定义深度优先搜索函数dfs</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i,j,board,word,index</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=row || j&lt;<span class="number">0</span> || j&gt;=col || board[i][j]!== word[index])&#123;</span><br><span class="line">            <span class="comment">// 约束搜索的边界不能在矩阵外与相等条件</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index === word.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 字符串遍历完成。函数栈的最顶，属于是最终的返回，随后开始依次回溯</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存当前值 </span></span><br><span class="line">        <span class="keyword">let</span> tmp = board[i][j];</span><br><span class="line">        <span class="comment">// 剪枝 后续的搜索不能走这个方向</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="comment">// 向四个方向搜索走到底（递归）</span></span><br><span class="line">        <span class="keyword">var</span> res = dfs(i-<span class="number">1</span>,j,board,word,index+<span class="number">1</span>) || dfs(i+<span class="number">1</span>,j,board,word,index+<span class="number">1</span>) || dfs(i,j-<span class="number">1</span>,board,word,index+<span class="number">1</span>) || dfs(i,j+<span class="number">1</span>,board,word,index+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//恢复现场给下一次搜索。遇到有路不通时要恢复</span></span><br><span class="line">        board[i][j] = tmp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//矩阵的行列</span></span><br><span class="line">    <span class="keyword">let</span> row = board.length;</span><br><span class="line">    <span class="keyword">let</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//找到起始位置，找错的话if里是false继续循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">            <span class="comment">//匹配对的话会一步步回溯true</span></span><br><span class="line">            <span class="keyword">if</span>(dfs(i,j,board,word,<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="comment">//直到所有都回溯完成，找到路径</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度$O(3^{k}MN)$<ul>
<li>最差情况每个起点遍历长度为k字符串的所有方案。共MN个起点</li>
</ul>
</li>
<li>空间复杂度O(k)<ul>
<li>搜索过程中递归深度不会超过k，因此函数累计使用的栈空间占用O(k)</li>
<li>最坏情况，k=MN，递归深度为MN</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>13 机器人的运动范围</title>
    <url>/2021/08/05/13/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<h2 id="解法一-DFS-回溯"><a href="#解法一-DFS-回溯" class="headerlink" title="解法一 DFS 回溯"></a>解法一 DFS 回溯</h2><ul>
<li>dfs通过递归先朝一个方向搜索到底。到底后返回上一个节点从另一个方向搜索</li>
<li>通过对象记录访问过的节点</li>
<li>边界条件<ul>
<li>不能越界</li>
<li>数位和小于k</li>
<li></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> movingCount = <span class="function"><span class="keyword">function</span>(<span class="params">m, n, k</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 数位之和计算</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">            x = <span class="built_in">Math</span>.floor(x/<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span>;<span class="comment">//记录总点数</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;<span class="comment">//满足的点</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i,j</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 越界弹出</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=m || j&gt;=n)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取数位和</span></span><br><span class="line">        <span class="keyword">let</span> sum = getSum(i) + getSum(j);</span><br><span class="line">        <span class="comment">// 把js值转为字符串</span></span><br><span class="line">        <span class="keyword">let</span> axis = <span class="built_in">JSON</span>.stringify([i,j])</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当该点还没走过且满足不大于k时继续执行</span></span><br><span class="line">        <span class="keyword">if</span>(sum&lt;=k &amp;&amp; !obj[axis])&#123;</span><br><span class="line">            total++;</span><br><span class="line">            <span class="comment">//标识该点走过</span></span><br><span class="line">            obj[axis] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//沿一个方向走到底</span></span><br><span class="line">            dfs(i+<span class="number">1</span>,j);</span><br><span class="line">            dfs(i,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> total; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>14 剪绳子</title>
    <url>/2021/08/14/14/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？</p>
<p>例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<h2 id="解法一-动态规划"><a href="#解法一-动态规划" class="headerlink" title="解法一 动态规划"></a>解法一 动态规划</h2><ul>
<li>首先定义函数f(n)为把长度为n的绳子剪成若干段后各段长度乘积的最大值</li>
<li>在剪第一刀是有n-1个选择。剪出来的第一段绳子可能分别为1,2，…，n-1</li>
<li>f(n)=max{f(i) x f(n-i)},其中0&lt;i&lt;n</li>
<li>这是一个从上至下的递归公式，会有很多重复的子问题，会有大量重复计算。因此从下而上计算，并依次保存</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> cuttingRope = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//几种简单情况</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="comment">//用数组保存结果</span></span><br><span class="line">    <span class="comment">//n=3是因為3&gt;1*2，其本身比分割的大，所以分割比3大的數字時候，3就不繼續往下分割了</span></span><br><span class="line">    <span class="keyword">let</span> result = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="comment">//从n=4开始计算每种子情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">4</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">        <span class="comment">//遍历到i/2即可 不然会有重复计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">const</span> product = result[j]*result[i-j]</span><br><span class="line">            <span class="keyword">if</span>(max &lt; product)&#123;</span><br><span class="line">                max = product</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result[i] = max</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度o(n_2)</p>
<p>空间复杂度 o(n)</p>
<h2 id="解法二-贪婪算法"><a href="#解法二-贪婪算法" class="headerlink" title="解法二 贪婪算法"></a>解法二 贪婪算法</h2><ul>
<li>贪婪算法的每一步贪婪选择都要得到最优解</li>
<li>数学证明当n&gt;=5时，3(n-3)&gt;=2(n-2)，因此尽可能多剪长度为3的绳子段</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(n === <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">   <span class="comment">//能有几个3</span></span><br><span class="line">   <span class="keyword">const</span> a = <span class="built_in">Math</span>.floor(n / <span class="number">3</span>);</span><br><span class="line"><span class="comment">//剩下的最后一段长度 可能是 0 1 2 </span></span><br><span class="line">   <span class="keyword">const</span> b = n % <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(b === <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="number">3</span>,a);</span><br><span class="line">   <span class="comment">//当剩余1时，对乘积没有贡献。不如看作少分一段且最后一段剩余4长度，2x2&gt;1x3</span></span><br><span class="line">   <span class="keyword">if</span>(b === <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="number">3</span>,a-<span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">   <span class="keyword">if</span>(b === <span class="number">2</span>)<span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="number">3</span>,a) * <span class="number">2</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>15 二进制中1的个数</title>
    <url>/2021/08/15/15/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数</p>
<h2 id="解法一-逐位判断-（超时）"><a href="#解法一-逐位判断-（超时）" class="headerlink" title="解法一 逐位判断 （超时）"></a>解法一 逐位判断 （超时）</h2><ul>
<li>位运算         <ul>
<li>设二进制数字为n</li>
<li>当n最右边的数字是1时，与1相与为1</li>
<li>当n最右边数字不是1时，与1相与为0</li>
</ul>
</li>
<li>时间复杂度 o($log_{2}n$)<ul>
<li>移位操作占用o(1)</li>
<li>逐位判断需要循环$log_{2}n$次，n代表最高位1所在位数</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span> - a positive integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        count += n&amp;<span class="number">1</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二-巧用n-amp-n-1"><a href="#解法二-巧用n-amp-n-1" class="headerlink" title="解法二 巧用n&amp;(n-1)"></a>解法二 巧用n&amp;(n-1)</h2><ul>
<li><p>n&amp;(n-1)的内涵</p>
<ul>
<li>二进制数n-1，结果会是最右边的1变成0，原来1后面的0变成1</li>
<li>n与n-1相与，结果是原来n最右边的1变成0</li>
</ul>
</li>
<li><p>一次与操作消灭一个1，计数+1，直到n为0时跳出循环</p>
</li>
<li><p>时间复杂度O(m),m为1的个数</p>
</li>
<li><p>空间复杂度O(1)</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span> - a positive integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        n &amp;= n-<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>16 数值的整数次方</title>
    <url>/2021/08/23/16/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p>
<h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><ul>
<li>n为负数时，取倒数</li>
<li>n为0时，返回1</li>
<li>n为正数时，正常计算</li>
<li>当x为0且n小于0，非法</li>
</ul>
<h2 id="解法一-循环-超时"><a href="#解法一-循环-超时" class="headerlink" title="解法一 循环 超时"></a>解法一 循环 超时</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x,n</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            result *= x</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span> &amp;&amp; n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/pow(x,<span class="built_in">Math</span>.abs(n))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> pow(x,n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul>
<li>通过递归，由最后一层的返回值的平方，依次计算出</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//递归到最后的返回</span></span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(n === -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>/x;</span><br><span class="line">    <span class="comment">// 偶次方 </span></span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>===<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> a = myPow(x,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a * a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 奇次方</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> b = myPow(x,(n-<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> b*b*x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(log2n)</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>17 打印从1到最大的n位数</title>
    <url>/2021/08/23/17/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>实际上，本题的主要考点时大数越界情况下的打印，需要解决以下三个问题</p>
<ul>
<li>表示大数的变量类型<ul>
<li>无论是 short / int / long … 任意变量类型，数字的取值范围都是有限的。因此，大数的表示应用字符串 String 类型。</li>
</ul>
</li>
<li>生成数字的字符串集</li>
<li>递归生成全排列</li>
</ul>
<h2 id="解法一-暴力循环（不适用于大数情况）"><a href="#解法一-暴力循环（不适用于大数情况）" class="headerlink" title="解法一 暴力循环（不适用于大数情况）"></a>解法一 暴力循环（不适用于大数情况）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> printNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = []</span><br><span class="line">    <span class="keyword">var</span> number = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        number *= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;number;i++)&#123;</span><br><span class="line">        result.push(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>20 表示数值的字符串</title>
    <url>/2021/08/29/20/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）<br>数值（按顺序）可以分成以下几个部分：</p>
<ul>
<li>若干空格</li>
<li>一个 小数 或者 整数</li>
<li>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数</li>
<li>若干空格</li>
</ul>
<p>小数（按顺序）可以分成以下几个部分：</p>
<ul>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>下述格式之一：</li>
<li><ul>
<li>至少一位数字，后面跟着一个点 ‘.’</li>
</ul>
</li>
<li><ul>
<li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li>
</ul>
</li>
<li><ul>
<li>一个点 ‘.’ ，后面跟着至少一位数字</li>
</ul>
</li>
</ul>
<p>整数（按顺序）可以分成以下几个部分：</p>
<ul>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>至少一位数字</li>
</ul>
<h2 id="解法一-字符串逐位扫描"><a href="#解法一-字符串逐位扫描" class="headerlink" title="解法一 字符串逐位扫描"></a>解法一 字符串逐位扫描</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isNumber = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 扫描字符串的光标</span></span><br><span class="line">  <span class="keyword">let</span> cursor = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 标识扫描是否有效的变量</span></span><br><span class="line">  <span class="keyword">let</span> isValid</span><br><span class="line">  <span class="comment">// 扫描有符号整数的函数</span></span><br><span class="line">  <span class="keyword">const</span> scanSignedInteger = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 遇到符号位 指针后移</span></span><br><span class="line">    <span class="keyword">if</span>(s[cursor] === <span class="string">&#x27;+&#x27;</span> || s[cursor] === <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">      cursor ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描无符号的数字部分</span></span><br><span class="line">    <span class="keyword">return</span> scanUnsignedInteger(s)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 扫描无符号数字部分的函数</span></span><br><span class="line">  <span class="keyword">const</span> scanUnsignedInteger = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 保存当前的指针位置</span></span><br><span class="line">    <span class="keyword">const</span> temp = cursor</span><br><span class="line">    <span class="comment">// 遇到数字后移</span></span><br><span class="line">    <span class="keyword">while</span>(s[cursor] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[cursor] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">      cursor ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前指针是否指向数字</span></span><br><span class="line">    <span class="keyword">return</span> s[temp] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[temp] &lt;= <span class="string">&#x27;9&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扫描过程</span></span><br><span class="line">  <span class="comment">// 1.跳过前面的空格</span></span><br><span class="line">  <span class="keyword">while</span>(s[cursor] === <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">    cursor ++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.扫描整数部分</span></span><br><span class="line">  isValid = scanSignedInteger(s)</span><br><span class="line">  <span class="comment">// 3.扫描小数点 再扫描小数点后面的整数</span></span><br><span class="line">  <span class="keyword">if</span>(s[cursor] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">    cursor++</span><br><span class="line">    <span class="keyword">if</span>(scanUnsignedInteger(s))&#123;</span><br><span class="line">      isValid = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 特别注意&#x27;3.&#x27;这种情况,虽然后面没整数，但isValid在扫描整数时已经是TRUE</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4.扫描有e的情况</span></span><br><span class="line">  <span class="keyword">if</span>(s[cursor]==<span class="string">&#x27;e&#x27;</span> || s[cursor]==<span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">    cursor ++</span><br><span class="line">    <span class="comment">// e前面一定要是有效整数</span></span><br><span class="line">    <span class="keyword">if</span>(isValid)&#123;</span><br><span class="line">      <span class="comment">// e后面可以是有符号整数</span></span><br><span class="line">      isValid = scanSignedInteger(s)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5.跳过后面的空格</span></span><br><span class="line">  <span class="keyword">while</span>(s[cursor] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">    cursor++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 6.排除空格后面仍然有内容的异常情况</span></span><br><span class="line">  <span class="keyword">if</span>(s[cursor] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isValid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>18 删除链表节点</title>
    <url>/2021/08/24/18/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<h2 id="解法一-遍历删除"><a href="#解法一-遍历删除" class="headerlink" title="解法一 遍历删除"></a>解法一 遍历删除</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = head</span><br><span class="line">    <span class="comment">// 删除头结点的情况</span></span><br><span class="line">    <span class="keyword">if</span>(node.val == val)&#123;</span><br><span class="line">        head = node.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除除了头结点外节点的情况</span></span><br><span class="line">    <span class="comment">// 遍历节点</span></span><br><span class="line">    <span class="keyword">while</span>(node.next.val != val)&#123;</span><br><span class="line">        node = node.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改指针</span></span><br><span class="line">    node.next = node.next.next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)</p>
<p>空间复杂度O(1)</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>21 调整数组顺序使奇数位于偶数前面</title>
    <url>/2021/08/30/21/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<h2 id="解法一-辅助数组合并"><a href="#解法一-辅助数组合并" class="headerlink" title="解法一 辅助数组合并"></a>解法一 辅助数组合并</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 奇数</span></span><br><span class="line">    <span class="keyword">let</span> odd = []</span><br><span class="line">    <span class="comment">// 偶数</span></span><br><span class="line">    <span class="keyword">let</span> even = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span> ;i &lt; nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            even.push(nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            odd.push(nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> odd.concat(even)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)<br>空间复杂度O(n)</p>
<h2 id="解法二-首尾双指针"><a href="#解法二-首尾双指针" class="headerlink" title="解法二 首尾双指针"></a>解法二 首尾双指针</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right = nums.length-<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> temp</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            left ++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            right --</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        temp = nums[left]</span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line">        nums[right] = temp</span><br><span class="line"></span><br><span class="line">        left ++ </span><br><span class="line">        right --</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)<br>空间复杂度O(1)</p>
<h2 id="解法三-快慢指针"><a href="#解法三-快慢指针" class="headerlink" title="解法三 快慢指针"></a>解法三 快慢指针</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slow = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> fast = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> temp</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">          temp = nums[fast]</span><br><span class="line">          nums[fast] = nums[slow]</span><br><span class="line">          nums[slow] = temp</span><br><span class="line">          slow ++</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        fast ++   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)<br>空间复杂度O(1)</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>22 链表中倒数第k个节点</title>
    <url>/2021/08/31/22/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个节点。</p>
<h2 id="解法一-双指针"><a href="#解法一-双指针" class="headerlink" title="解法一 双指针"></a>解法一 双指针</h2><ul>
<li>定义前后两个指针</li>
<li>先让后指针比前指针快k步</li>
<li>当后指针刚好移出链表时，前指针即为倒数第k个<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getKthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> former = head</span><br><span class="line">    <span class="keyword">let</span> latter = head</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        latter = latter.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(latter != <span class="literal">null</span>)&#123;</span><br><span class="line">        latter = latter.next</span><br><span class="line">        former = former.next</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> former</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
时间复杂度O(n)<br>空间复杂度O(1)</li>
</ul>
<h2 id="解法二-笨方法-数组依次存储返回"><a href="#解法二-笨方法-数组依次存储返回" class="headerlink" title="解法二 笨方法 数组依次存储返回"></a>解法二 笨方法 数组依次存储返回</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getKthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> node = head;</span><br><span class="line">    <span class="keyword">let</span> arr = [];<span class="comment">//存储各个节点</span></span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">0</span>] = head;</span><br><span class="line">    <span class="keyword">while</span>(node.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">        arr[length] = node;</span><br><span class="line">        length += <span class="number">1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[length-k];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)<br>空间复杂度O(n)</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>24 反转链表</title>
    <url>/2021/08/31/24/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<h2 id="解法一-双指针"><a href="#解法一-双指针" class="headerlink" title="解法一 双指针"></a>解法一 双指针</h2><ul>
<li>遍历链表，并在访问各节点时修改 next 引用指向</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span> , cur = head</span><br><span class="line">    <span class="keyword">let</span> temp</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 暂存当前节点的下一个节点</span></span><br><span class="line">        temp = cur.next</span><br><span class="line">        <span class="comment">// 修改指针指向</span></span><br><span class="line">        cur.next = pre</span><br><span class="line">        <span class="comment">// 双指针后移</span></span><br><span class="line">        pre = cur</span><br><span class="line">        cur = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)<br>空间复杂度O(1)</p>
<h2 id="解法二-递归"><a href="#解法二-递归" class="headerlink" title="解法二 递归"></a>解法二 递归</h2><ul>
<li>递归法遍历链表，当越过尾节点后终止递归，在回溯时修改各节点的 next 引用指向。</li>
<li>递归函数：</li>
<li><ul>
<li>终止条件：当 cur 为空，则返回尾节点 pre （即反转链表的头节点）；</li>
</ul>
</li>
<li><ul>
<li>递归后继节点，记录返回值（即反转链表的头节点）为 res ；</li>
</ul>
</li>
<li><ul>
<li>修改当前节点 cur 引用指向前驱节点 pre ；</li>
</ul>
</li>
<li><ul>
<li>返回反转链表的头节点 res ；</li>
</ul>
</li>
<li>递归的模板，</li>
<li><ul>
<li>终止条件 </li>
</ul>
</li>
<li>– 链表为空，或者是链表没有尾结点的时候</li>
<li><ul>
<li>递归调用</li>
</ul>
</li>
<li>– 从当前节点的下一个结点开始递归</li>
<li><ul>
<li>逻辑处理</li>
</ul>
</li>
<li>– 把当前节点挂到递归之后的链表的末尾</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存当前节点的下一个节点</span></span><br><span class="line">    <span class="keyword">let</span> next = head.next</span><br><span class="line">    <span class="comment">// 从当前节点的下一个节点开始递归</span></span><br><span class="line">    <span class="keyword">let</span> reverse = reverseList(next)</span><br><span class="line">    <span class="comment">// 修改指向</span></span><br><span class="line">    head.next.next = head</span><br><span class="line">    head.next = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reverse</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。</p>
<p>空间复杂度：O(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>25 合并两个排序的链表</title>
    <url>/2021/09/01/25/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<h2 id="解法-双指针-伪头节点"><a href="#解法-双指针-伪头节点" class="headerlink" title="解法 双指针+伪头节点"></a>解法 双指针+伪头节点</h2><ul>
<li>定义一个伪节点</li>
<li>比较两个链表的头节点大小，依次添加到伪节点后</li>
<li><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dum = <span class="keyword">new</span> ListNode(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> cur = dum</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 !== <span class="literal">null</span> &amp;&amp; l2 !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            cur.next = l1</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur.next = l2</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// l1或l2其中一个完了 跳出循环</span></span><br><span class="line">    <span class="comment">// 三目运算符 l1不为空时赋l1 为空时赋l2</span></span><br><span class="line">    cur.next = l1 != <span class="literal">null</span> ? l1 : l2</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伪节点的作用</span></span><br><span class="line">    <span class="keyword">return</span> dum.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
时间复杂度O(m+n)<br>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>28 对称的二叉树</title>
    <url>/2021/12/07/28%20%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<h2 id="解法一-递归"><a href="#解法一-递归" class="headerlink" title="解法一 递归"></a>解法一 递归</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">leftNode, rightNode</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 最后一层的情况</span></span><br><span class="line">        <span class="keyword">if</span>(leftNode==<span class="literal">null</span> &amp;&amp; rightNode==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排除只有一边冒头 和 值不相等的情况</span></span><br><span class="line">        <span class="keyword">if</span>(leftNode==<span class="literal">null</span> || rightNode==<span class="literal">null</span> || leftNode.val != rightNode.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 往两边逐层递归走到底 再逐层向上弹出</span></span><br><span class="line">        <span class="keyword">return</span> search(leftNode.left,rightNode.right) &amp;&amp; search(leftNode.right,rightNode.left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 树空也是对称的</span></span><br><span class="line">    <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 开始递归 </span></span><br><span class="line">    <span class="keyword">return</span> search(root.left, root.right)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>26 树的子结构</title>
    <url>/2022/01/09/26%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<h2 id="解法一-先序遍历-包含判断"><a href="#解法一-先序遍历-包含判断" class="headerlink" title="解法一 先序遍历 + 包含判断"></a>解法一 先序遍历 + 包含判断</h2><ul>
<li>先遍历树A中的每个节点$n_{A}$ (对应函数isSubStructure(A,B))<ul>
<li>isSubStructure(A,B)函数<ul>
<li>特例处理<ul>
<li>当A或B为空时，返回false</li>
</ul>
</li>
<li>返回值：若B是A的子结构，必须满足三种情况之一<ul>
<li>树B是树子根节点的子结构，对应recur(A,B)</li>
<li>树B是树A左子树的子结构，对应isSubStructure（A.left,B）</li>
<li>树B是树A右子树的子结构，对应isSubStructure（A.right,B)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>判断A中以$n_{A}$为根节点的子树时候包含树B (对应函数recur(A,B))<ul>
<li>recur（A,B) 函数<ul>
<li>终止条件：<ul>
<li>当节点B为空：说明B已经完成匹配（越过叶子节点），返回True</li>
<li>当节点A为空：说明已经越过树A叶子节点，即匹配失败，返回False</li>
<li>当节点A和B的值不同：说明匹配失败</li>
</ul>
</li>
<li>返回值<ul>
<li>判断A和B的左子节点是否相等    即recur(A.left,B.left)</li>
<li>判断A和B的右子节点是否相等    即recur(A.right,B.right)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">A</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">B</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSubStructure = <span class="function"><span class="keyword">function</span>(<span class="params">A, B</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断A B为空直接弹出</span></span><br><span class="line">    <span class="keyword">if</span>(A == <span class="literal">null</span> || B == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一种情况   B是A根节点子树的子结构</span></span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (A.val == B.val &amp;&amp; recur(A.left,B.left) &amp;&amp; recur(A.right,B.right))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二三种情况 B是A左子树的子结构 和 B是A右子树的子结构</span></span><br><span class="line">    <span class="keyword">return</span> isSubStructure(A.left, B) || isSubStructure(A.right,B)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过递归判断两个输入结构的包含关系</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recur</span>(<span class="params">A, B</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="literal">null</span>)   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">null</span>)   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span>(A.val != B.val)  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>29 顺时针打印矩阵</title>
    <url>/2021/09/05/29/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<h2 id="解法一-模拟、设定边界"><a href="#解法一-模拟、设定边界" class="headerlink" title="解法一 模拟、设定边界"></a>解法一 模拟、设定边界</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> spiralOrder = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(matrix.length==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> top = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> right = matrix[<span class="number">0</span>].length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> bottom = matrix.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="comment">// while循环只遍历环 不成环就不遍历了</span></span><br><span class="line">  <span class="keyword">while</span>(top &lt; bottom &amp;&amp; left &lt; right)&#123;</span><br><span class="line">    <span class="comment">// 上层路</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=left;i&lt;right;i++)&#123;</span><br><span class="line">      result.push(matrix[top][i])</span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 右层路</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=top;i&lt;bottom;i++)&#123;</span><br><span class="line">      result.push(matrix[i][right])</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 下层路</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=right;i&gt;left;i--)&#123;</span><br><span class="line">      result.push(matrix[bottom][i])</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 左层路</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=bottom;i&gt;top;i--)&#123;</span><br><span class="line">      result.push(matrix[i][left])</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 缩圈</span></span><br><span class="line">    right--</span><br><span class="line">    top++</span><br><span class="line">    bottom--</span><br><span class="line">    left++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理不成环的数据</span></span><br><span class="line">  <span class="comment">// 剩下一行，从左到右依次添加</span></span><br><span class="line">  <span class="keyword">if</span>(top == bottom &amp;&amp; left != right)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = left;i&lt;=right;i++)&#123;</span><br><span class="line">      result.push(matrix[top][i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 剩下一个</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(top==bottom &amp;&amp; left == right)&#123;</span><br><span class="line">    result.push(matrix[left][top])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 剩下一列，从上到下依次添加</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(left == right &amp;&amp; top!=bottom)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=top;i&lt;=bottom;i++)&#123;</span><br><span class="line">      result.push(matrix[i][left])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(mn)<br>空间复杂度O(mn)</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>31 栈的压入弹出</title>
    <url>/2021/12/07/31%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<h2 id="解法一-辅助栈"><a href="#解法一-辅助栈" class="headerlink" title="解法一 辅助栈"></a>解法一 辅助栈</h2><ul>
<li>按入栈顺序依次入辅助栈</li>
<li>每次入栈后，循环判断“辅助栈顶元素是否与出栈序列当前元素相等”<ul>
<li>辅助栈栈顶元素出栈</li>
<li>出栈序列元素顺延一位</li>
</ul>
</li>
<li>最后辅助栈为空则为正确匹配</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> validateStackSequences = <span class="function"><span class="keyword">function</span>(<span class="params">pushed, popped</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> pushed)&#123;</span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        stack.push(num)</span><br><span class="line">        <span class="comment">// 栈不为空时，判断栈顶元素与出栈列表index元素的是否相等</span></span><br><span class="line">        <span class="keyword">while</span>(stack.length &amp;&amp; stack[stack.length-<span class="number">1</span>]==popped[index])&#123;          </span><br><span class="line">            stack.pop()</span><br><span class="line">            index ++                 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果最后栈为空则为正确</span></span><br><span class="line">    <span class="keyword">return</span> stack.length === <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>30 包含min函数的栈</title>
    <url>/2022/01/09/30%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<h2 id="解法一-常规"><a href="#解法一-常规" class="headerlink" title="解法一 常规"></a>解法一 常规</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> MinStack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stack = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MinStack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stack.push(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MinStack.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stack.pop()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MinStack.prototype.top = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack[<span class="built_in">this</span>.stack.length-<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MinStack.prototype.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,<span class="built_in">this</span>.stack)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解法二-辅助栈"><a href="#解法二-辅助栈" class="headerlink" title="解法二 辅助栈"></a>解法二 辅助栈</h2><ul>
<li>根据题意，我们需要在常量级的时间内找到最小值！</li>
<li>这说明，我们绝不能在需要最小值的时候，再做排序，查找等操作来获取！</li>
<li>所以，我们可以创建两个栈，一个栈是主栈 stack，另一个是辅助栈 minStack，用于存放对应主栈不同时期的最小值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> MinStack = function() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = []</span><br><span class="line">    <span class="keyword">this</span>.minStack = [Infinity] <span class="comment">//放入一个无限大，确保push第一个数值时，minStack能push进同样的数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;void&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.push = function(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.push(x)</span><br><span class="line">	<span class="keyword">this</span>.minStack.push(Math.min(<span class="keyword">this</span>.minStack[<span class="keyword">this</span>.minStack.length-<span class="number">1</span>], x))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;void&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.pop = function() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.pop()</span><br><span class="line">    <span class="keyword">this</span>.minStack.pop()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.top = function() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.stack.length-<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.min = function() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.minStack[<span class="keyword">this</span>.minStack.length-<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>32 从上到下打印二叉树</title>
    <url>/2021/12/09/32%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目描述1"><a href="#题目描述1" class="headerlink" title="题目描述1"></a>题目描述1</h2><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。又称二叉树的广度优先搜索BFS</p>
<h3 id="解法-借助队列先入先出的特性"><a href="#解法-借助队列先入先出的特性" class="headerlink" title="解法 借助队列先入先出的特性"></a>解法 借助队列先入先出的特性</h3><p>1.特例处理： 当树的根节点为空，则直接返回空列表 [] ；<br>2.初始化： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；<br>3.BFS 循环： 当队列 queue 为空时跳出；<br>    出队： 队首元素出队，记为 node；<br>    打印： 将 node.val 添加至列表 tmp 尾部；<br>    添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义队列</span></span><br><span class="line">    <span class="keyword">let</span> queue = [root]</span><br><span class="line">    <span class="comment">// 定义返回的列表</span></span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="comment">// 队列不为空时 循环弹出</span></span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="comment">// 取出队列弹出的节点</span></span><br><span class="line">        <span class="keyword">let</span> node = queue.shift()</span><br><span class="line">        <span class="comment">// 存入返回的列表</span></span><br><span class="line">        result.push(node.val)</span><br><span class="line">        <span class="comment">// 逐层存入每层节点的左右子节点</span></span><br><span class="line">        <span class="keyword">if</span>(node.left)&#123;</span><br><span class="line">            queue.push(node.left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right)&#123;</span><br><span class="line">            queue.push(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(N)</p>
<p>空间复杂度 O(N)</p>
<h2 id="题目描述2"><a href="#题目描述2" class="headerlink" title="题目描述2"></a>题目描述2</h2><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，<strong>每一层打印到一行</strong>。</p>
<h3 id="解法-借助队列先入先出的特性-1"><a href="#解法-借助队列先入先出的特性-1" class="headerlink" title="解法 借助队列先入先出的特性"></a>解法 借助队列先入先出的特性</h3><p>与题1相似，只是在多了一个要求，每一层打印到一行</p>
<p>因此要多套一个<strong>当前层打印循环</strong>，即在该层中的元素都存入一个子列表，然后添加进最后的返回列表</p>
<p>但如何能做到仅循环当前层元素个数的次数呢？</p>
<p>一开始这样进行，发现后面queue添加子节点后，循环次数收到影响</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(let i = 0; i &lt; queue.length; i++)</span><br></pre></td></tr></table></figure>

<p>如何不受到添加节点的影响呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(let i = queue.length; i &gt; 0; i--)</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> queue = [root]</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = []</span><br><span class="line"> 		<span class="comment">// 循环二叉树当前层的节点个数，从后向前循环才能不受添加子节点的影响</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = queue.length; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift()</span><br><span class="line">            tmp.push(node.val)</span><br><span class="line">            <span class="keyword">if</span>(node.left)&#123;</span><br><span class="line">                queue.push(node.left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right)&#123;</span><br><span class="line">                queue.push(node.right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(tmp)          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="题目描述3"><a href="#题目描述3" class="headerlink" title="题目描述3"></a>题目描述3</h2><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。本题额外要求 <strong>打印顺序交替变化</strong></p>
<h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>在题2的基础上，加入index来标识奇偶数层，对于每层的子列表tmp，奇偶数层的元素采用不同的加入方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> queue = [root]</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 循环每一层</span></span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = []</span><br><span class="line"> 		<span class="comment">// 循环二叉树当前层的节点个数，从后向前循环才能不受添加子节点的影响</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = queue.length; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">// 弹出队首元素</span></span><br><span class="line">            <span class="keyword">let</span> node = queue.shift()</span><br><span class="line">            <span class="comment">// 奇数层从左往右 即先来的从尾部进去</span></span><br><span class="line">            <span class="keyword">if</span>(index % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                tmp.push(node.val)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 偶数层从右往左 即先来的从头部进去</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tmp.unshift(node.val)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把当前节点的左右节点添加进</span></span><br><span class="line">            <span class="keyword">if</span>(node.left)&#123;</span><br><span class="line">                queue.push(node.left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right)&#123;</span><br><span class="line">                queue.push(node.right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(tmp)  </span><br><span class="line">        index ++        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>在题2的基础上，加入index来标识奇偶数层，偶数层将tmp翻转</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> queue = [root]</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 循环每一层</span></span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = []</span><br><span class="line"> 		<span class="comment">// 循环二叉树当前层的节点个数，从后向前循环才能不受添加子节点的影响</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = queue.length; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">// 弹出队首元素</span></span><br><span class="line">            <span class="keyword">let</span> node = queue.shift()</span><br><span class="line">            tmp.push(node.val)</span><br><span class="line">            <span class="comment">// 把当前节点的左右节点添加进</span></span><br><span class="line">            <span class="keyword">if</span>(node.left)&#123;</span><br><span class="line">                queue.push(node.left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right)&#123;</span><br><span class="line">                queue.push(node.right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于偶数层，对tmp进行翻转</span></span><br><span class="line">        <span class="keyword">if</span>(index % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            tmp  = tmp.reverse()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result.push(tmp)  </span><br><span class="line">        index ++        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>33 二叉搜索树的后序遍历</title>
    <url>/2022/01/10/33%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li>后续遍历<ul>
<li>按照左节点、右节点、根节点的顺序遍历</li>
<li>划分左右子树<ul>
<li>最后一个元素总是根节点</li>
<li>前排元素为左子树节点</li>
<li>通过找到第一个比根节点大的节点，锁定右子树</li>
</ul>
</li>
</ul>
</li>
<li>二叉搜索树的定义<ul>
<li>左子树中所有节点&lt;根节点的值</li>
<li>右子树中所有节点&gt;根节点的值</li>
</ul>
</li>
</ul>
<h2 id="方法一-递归分治"><a href="#方法一-递归分治" class="headerlink" title="方法一 递归分治"></a>方法一 递归分治</h2><ul>
<li><p>根据 二叉搜索树的定义，通过递归判断所有子树的正确性。若所有子树都正确，则后序遍历序列正确</p>
</li>
<li><p>遍历终止条件</p>
<ul>
<li>当i &gt;= j ，说明此子树节点数量&lt;=1，无需判别正确性，直接返回True</li>
</ul>
</li>
<li><p>递归工作 输入头尾位置 i ,  j</p>
<ul>
<li>划分左右子树和根<ul>
<li>找到第一个 大于等于 根节点的节点，索引为m</li>
<li>确定左子树区间[i,m-1]</li>
<li>确定右子树区间[m,j-1]</li>
<li>根节点j</li>
</ul>
</li>
<li>判断划分的区间是否正确<ul>
<li>左子树区间[i,m-1]内的所有节点都应 &lt; j。这一点肯定满足，因为是通过找第一个大于根节点锁定区间，<strong>只需判断右子树是否正确</strong></li>
<li>右子树区间[m,j-1]内所有节点都应&gt;j。通过遍历，当遇到小于等于的节点直接跳出遍历。最后可通过遍历的标志p=j判断是否为二叉搜索树</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：所有子树都需正确。使用与逻辑&amp;&amp;</p>
<ul>
<li>p = j 判断此树是否正确</li>
<li>recur(i,m-1)判断左子树是否正确</li>
<li>recur(m,j-1）判断右子树是否正确</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">postorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> verifyPostorder = <span class="function"><span class="keyword">function</span>(<span class="params">postorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recur(postorder, <span class="number">0</span>, postorder.length-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 定义向下递归判断划分是否正确的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recur</span>(<span class="params">postorder, i, j</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定位到第一个比根元素大的元素 划分左右子树</span></span><br><span class="line">        <span class="keyword">let</span> p = i</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[j])&#123;</span><br><span class="line">            p++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> m = p</span><br><span class="line">        <span class="comment">// 判断右子树段中是否都大于根节点</span></span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[j])&#123;</span><br><span class="line">            p++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若右子树正确则划分都正确，即p==j</span></span><br><span class="line">        <span class="keyword">return</span> p==j &amp;&amp; recur(postorder,i,m-<span class="number">1</span>) &amp;&amp; recur(postorder,m,j-<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>35 复杂链表的复制</title>
    <url>/2021/09/05/35/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<ul>
<li>本题难点在于复制链表的过程中构建新链表各节点的random指向</li>
</ul>
<h2 id="解法一-哈希表"><a href="#解法一-哈希表" class="headerlink" title="解法一 哈希表"></a>解法一 哈希表</h2><ul>
<li>利用哈希表的查询特点，考虑构建原链表节点和新链表节点的键值对映射关系</li>
<li>再遍历构建新链表各节点的next和random引用指向</li>
<li>算法流程</li>
<li><ul>
<li>若头节点head为空节点，直接返回null</li>
</ul>
</li>
<li><ul>
<li>初始化：哈希表dic，节点cur指向头节点</li>
</ul>
</li>
<li><ul>
<li>复制链表：</li>
</ul>
</li>
<li>– 建立新节点，并向dic添加键值对(原cur节点，新cur节点)</li>
<li>– cur遍历至原链表下一节点</li>
<li><ul>
<li>构建新链表的引用指向</li>
</ul>
</li>
<li>– 构建新节点next和random引用指向</li>
<li>– cur遍历至原链表的下一节点</li>
<li><ul>
<li>返回新链表的头节点dic[cur]</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> copyRandomList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head==<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  dic = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> cur = head</span><br><span class="line">  <span class="comment">// 复制链表 建立原节点-&gt;新节点的map映射</span></span><br><span class="line">  <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">    dic.set(cur,<span class="keyword">new</span> Node(cur.val))</span><br><span class="line">    cur = cur.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构建新节点的next和random指向</span></span><br><span class="line">  <span class="comment">// 哈希表的作用在于通过原节点索引到新节点</span></span><br><span class="line">  cur = head</span><br><span class="line">  <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">    dic.get(cur).next = dic.get(cur.next)</span><br><span class="line">    dic.get(cur).random = dic.get(cur.random)</span><br><span class="line">    cur = cur.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">  <span class="keyword">return</span> dic.get(head)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)<br>空间复杂度O(n)</p>
<h2 id="解法二-拼接-拆分"><a href="#解法二-拼接-拆分" class="headerlink" title="解法二 拼接 + 拆分"></a>解法二 拼接 + 拆分</h2><ul>
<li>考虑构建原节点1-&gt;新节点1-&gt;原节点2-&gt;新节点2的拼接链表</li>
<li>如此便可通过原节点找到新节点</li>
<li>算法流程</li>
<li><ul>
<li>复制各节点，构建拼接链表</li>
</ul>
</li>
<li><ul>
<li>构建新链表各节点的random指向</li>
</ul>
</li>
<li><ul>
<li>拆分原/新链表</li>
</ul>
</li>
<li><ul>
<li>返回新链表的头节点<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> copyRandomList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 复制节点，将新节点放到原节点后面</span></span><br><span class="line">  <span class="keyword">let</span> cur = head</span><br><span class="line">  <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">    cur.next = <span class="keyword">new</span> Node(cur.val,cur.next)</span><br><span class="line">    cur = cur.next.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构建新节点的random指向</span></span><br><span class="line">  cur = head</span><br><span class="line">  <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">    <span class="comment">// 建立新节点之间的random联系</span></span><br><span class="line">    cur.next.random = cur.random ? cur.random.next:<span class="literal">null</span> </span><br><span class="line">    cur = cur.next.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拆分链表</span></span><br><span class="line">  <span class="keyword">let</span> newNode = head.next</span><br><span class="line">  <span class="keyword">let</span> res = newNode</span><br><span class="line">  cur = head</span><br><span class="line">  <span class="keyword">while</span>(cur.next &amp;&amp; newNode.next)&#123;</span><br><span class="line">    <span class="comment">// 原链表连接</span></span><br><span class="line">    cur.next = cur.next.next</span><br><span class="line">    <span class="comment">// 建立新链表next联系</span></span><br><span class="line">    newNode.next = newNode.next.next </span><br><span class="line">    <span class="comment">// 移动</span></span><br><span class="line">    cur = cur.next</span><br><span class="line">    newNode = newNode.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 单独处理原链表的尾结点</span></span><br><span class="line">  cur.next = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
